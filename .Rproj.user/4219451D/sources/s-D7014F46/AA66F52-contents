---
title: "pbc2 data analysis"
output: 
  html_document:
    df_print: paged
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(joineRML)
library(dplyr)
library(epiR)
library(epiDisplay)
library(lcmm)
library(lattice)
library(nlme)
library(ggplot2)
library(lme4)
library(mfp)
data("pbc2")
```

```{r}
str(pbc2)
pbc2$id <- as.integer(pbc2$id)
```

# Temps landmark à 4 ans

```{r}
pbc2_landmark <- pbc2[which(pbc2$year<4),]
quantile(table(pbc2_landmark$id))
```

## serBilir

### Normalité des variables quantitatives

```{r}
normality_hist <- function(data, var_time, var_quanti, nb_quantile){
  quant_year <- quantile(data[,var_time], 
                         probs = seq(from = 0, to = 1, length.out = nb_quantile))
  par(mfrow = c(round(sqrt(nb_quantile)),round(sqrt(nb_quantile))))
  
  for(i in seq_len(nb_quantile - 1)){
    hist(data[which(quant_year[i] <= data[,var_time] &
                      quant_year[i + 1] >= data[,var_time]), var_quanti],
         breaks = 30, col = "blue",
         main = paste(round(quant_year[i], 1), "<=", "year", "<=",
                      round(quant_year[i+1], 1)),
         xlab = paste(var_quanti,"value"))
  }
  
}
```

```{r}
hist(pbc2_landmark$serBilir, breaks = 30)
normality_hist(pbc2_landmark, "year", "serBilir", 5)
# probleme de normalité
```

On transforme la variable pour obtenir une distribution normale

```{r}
pbc2_landmark$serBilir2 <- log(pbc2_landmark$serBilir+0.1)

hist(pbc2_landmark$serBilir2, breaks = 30)
normality_hist(pbc2_landmark, "year", "serBilir2", 5)
```

### Fonction du temps

Spaghetti plot

```{r}
ggplot(pbc2_landmark) +
  geom_line(aes(x = year, y = serBilir2, group = id), color = "grey30", alpha = 0.8) +
  stat_smooth(aes(x = year, y = serBilir2), method = "loess", size = 0.75, color = "red") +
  theme_bw()
```

Modélisation du temps en fonction de polynomes fractionnés

```{r}
pf <- mfp(serBilir2 ~ fp(year, df = 4, select = 1, scale = TRUE), data = pbc2_landmark)
pf
```

On garde le temps comme une fonction linéaire

### Modele mixte

#### Modele complet

```{r}
lmm_serBilir <- hlme(fixed = serBilir2~year+age+sex+drug+
                       year*age+year*sex+year*drug,
                    random = ~1+year,
                    subject = 'id',
                    data = pbc2_landmark)

summary(lmm_serBilir)
```

#### Modele restreint (selection par pas à pas descendant p<0.05)

```{r}
lmm_serBilir <- hlme(fixed = serBilir2~year+sex+
                       year*sex,
                    random = ~1+year,
                    subject = 'id',
                    data = pbc2_landmark)

summary(lmm_serBilir)
```

#### Adequation du modele

```{r}
# homoscedasticité
plot(lmm_serBilir)
```

#### Estimation des effets aléatoires

```{r}
Z <- as.matrix(data.frame(intercept = rep(1, nrow(pbc2_landmark)),
                year = pbc2_landmark[,"year"]))
B <- matrix(c(lmm_serBilir$best[5], lmm_serBilir$best[6], lmm_serBilir$best[6], lmm_serBilir$best[7])
            , 2, 2)
X <- data.frame(intercept = rep(1, nrow(pbc2_landmark)),
                year = pbc2_landmark[,"year"],
                sex = as.integer(pbc2_landmark[,"sex"]) - 1)
X[,"year:sex"] <- X$year * X$sex
X <- as.matrix(X)

Y <- matrix(pbc2_landmark$serBilir2, ncol = 1)

beta <- matrix(lmm_serBilir$best[1:4], ncol = 1)
```

#### Matrice par individus

```{r}
predRE <- matrix(NA, nrow = length(unique(pbc2_landmark$id)), ncol = ncol(Z),
                 dimnames = list(unique(pbc2_landmark$id),
                                 colnames(Z)))
predRE_row <- 1

for (num_id in unique(pbc2_landmark$id)){
  Z_i <- matrix(Z[which(pbc2_landmark$id==num_id),], 
                ncol = ncol(Z),
                dimnames = list(NULL,colnames(Z)))
  
  V_i <- Z_i%*%B%*%t(Z_i) + 
    (lmm_serBilir$best[length(lmm_serBilir$best)]^2*
       diag(nrow(pbc2_landmark[which(pbc2_landmark$id==num_id),])))
  
  Y_i <- matrix(Y[which(pbc2_landmark$id==num_id),], ncol = 1)
  
  X_i <- matrix(X[which(pbc2_landmark$id==num_id),], 
                ncol = ncol(X),
                dimnames = list(NULL, colnames(X)))
  
  b_i <- B%*%t(Z_i)%*%solve(V_i)%*%(Y_i-X_i%*%beta)
  
  predRE[predRE_row,] <- b_i
  
  predRE_row <- predRE_row + 1
}
```

#### Estimation effets aleatoires pour un nouvel individu

```{r}
newdata <- data.frame(id = c(999, 999, 999, 479),
                      year = c(0, 0.475, 1.147, 0),
                      sex = c(1, 1, 1, 0),
                      serBilir2 = c(0.214, 0.249, 0.343, 0.341))

predRE_newdata <- function(model, newdata){
  
  formul <- model$call
  
  subject <- formul$subject
  
  num_fixed_effect <- length(model$Xnames)
  num_random_effect <- ncol(model$predRE) - 1
  
  num_param_fixed <- length(model$Xnames)
  num_param_effect <- (num_random_effect * (num_random_effect+1))/2
  
  # fixed regression coefficients
  beta <- matrix(model$best[1:num_param_fixed], ncol = 1)
  rownames(beta) <- names(model$best[1:num_param_fixed])
  colnames(beta) <- "beta"
  
  vcov_re <- model$best[(num_param_fixed+1):(num_param_fixed+num_param_effect)]
  
  # variance covariance random effects
  B <- matrix(NA, nrow = num_random_effect, ncol = num_random_effect, byrow = TRUE)
  
  ind_var_re <- 1
  
  for (ind_row in 1:ncol(B)){
    for (ind_col in 1:ind_row){
      B[ind_row, ind_col] <- vcov_re[ind_var_re]
      ind_var_re <- ind_var_re + 1
    }
  }
  
  B[upper.tri(B, diag = F)] <- B[lower.tri(B, diag = F)]
  
  # stardard error
  se <- model$best[length(model$best)]
  
  # random design matrix
  
  Z_formula <- as.formula(formul$random)
  Z <- model.matrix(Z_formula, newdata)
  
  # à automatiser en fonction des variables du model
  # fixed design matrix
  
  X_formula <- as.formula(as.character(formul$fixed)[-2])
  X <- model.matrix(X_formula, newdata)
  
  # outcome
  Y_formula <- as.formula(paste(as.character(formul$fixed)[1], "-1+", as.character(formul$fixed)[2]))
  Y <- model.matrix(Y_formula, newdata)

  predRE <- matrix(NA, nrow = length(unique(newdata[,subject])), ncol = num_random_effect,
                   dimnames = list(unique(newdata[,subject]), colnames(Z)))
  predRE_row <- 1
  
  for (ind_subject in unique(newdata[,subject])){
    
    ind <- which(newdata[,subject]==ind_subject)
    
    tot_subject <- nrow(newdata[ind,])
    
    Z_i <- matrix(Z[ind,], nrow = tot_subject)
    V_i <- Z_i%*%B%*%t(Z_i) + se^2*diag(tot_subject)
    Y_i <- Y[ind,]
    X_i <- X[ind,]
    b_i <- B%*%t(Z_i)%*%solve(V_i)%*%(Y_i-X_i%*%beta)
    
    predRE[predRE_row,] <- b_i
    
    predRE_row <- predRE_row + 1
  }
  
  return(list(b_i = predRE,
              beta = beta,
              formul = model$call))
  
}

predRE_newdata(lmm_serBilir, newdata)
```

#### Calcul des resumes au temps landmark

##### Valeur du marqueur

```{r}
predRE <- predRE_newdata(lmm_serBilir, newdata)

newdata2 <- data.frame(id = c(999, 479),
                       year = c(4,4),
                       sex = c(1,0))

predY_newdata <- function(predRE, newdata){
  
  formul <- predRE$formul
  
  beta <- predRE$beta
  b <- t(predRE$b_i)
  
  subject <- predRE$formul$subject
  
  num_fixed_effect <- length(beta)
  num_random_effect <- nrow(b)
  
  X_formula <- as.formula(as.character(formul$fixed)[-2])
  X <- model.matrix(X_formula, newdata)
  
  Z_formula <- as.formula(formul$random)
  Z <- model.matrix(Z_formula, newdata)
  
  predY <- matrix(NA, nrow = length(unique(newdata[,subject])), ncol = 1,
                   dimnames = list(unique(newdata[,subject]), "predY"))
  
  predY_row <- 1
  
  for (ind_subject in unique(newdata[,subject])){
    
    ind <- which(newdata[,subject]==ind_subject)
    
    b_i <- b[,ind]
    X_i <- X[ind,]
    Z_i <- Z[ind,]
    
    predY_i <- X_i%*%beta + Z_i%*%b_i
    
    predY[predY_row,] <- predY_i
    
    predY_row <- predY_row + 1
    
  }
  
  return(predY)
}

predY_newdata(predRE, newdata2)
```

##### Trajectoire du marqueur

```{r}
derivForm <- list(fixed = ~ 1 + sex + I(2*year),
                  indFixed = c(2,4,5),
                  random = ~ 1 + I(2*year),
                  indRandom = c(2,3))

derivForm <- list(fixed = ~ 1 + sex,
                  indFixed = c(2,4),
                  random = ~ 1,
                  indRandom = 2)

derivY_newdata <- function(predRE, newdata, derivForm){
  
  subject <- predRE$formul$subject
  
  beta_deriv <- predRE$beta[derivForm$indFixed, , drop = FALSE]
  b_deriv <- t(predRE$b_i[,derivForm$indRandom])
  
  X_deriv_formula <- derivForm$fixed
  X_deriv <- model.matrix(X_deriv_formula, newdata)
  
  Z_deriv_formula <- derivForm$random
  Z_deriv <- model.matrix(Z_deriv_formula, newdata)

  Y_deriv <- matrix(NA, nrow = length(unique(newdata[,subject])), ncol = 1,
                   dimnames = list(unique(newdata[,subject]), "Y_deriv"))
  
  Y_deriv_row <- 1
  
  for (ind_subject in unique(newdata[,subject])){
    
    ind <- which(newdata[,subject]==ind_subject)
    
    b_i_deriv <- b_deriv[,ind]
    X_i_deriv <- X_deriv[ind,]
    Z_i_deriv <- Z_deriv[ind,]
    
    Y_i_deriv <- X_i_deriv%*%beta_deriv + Z_i_deriv%*%b_i_deriv
    
    Y_deriv[Y_deriv_row,] <- Y_i_deriv
    
    Y_deriv_row <- Y_deriv_row + 1
    
  }
  
  return(Y_deriv)
}

derivY_newdata(predRE, newdata2, derivForm)
```

##### Cumul des dernières années

```{r}

cumulY_newdata <- function(predRE, newdata, var_integrate, tHW, tLM){
  
  subject <- predRE$formul$subject
  
  Y_cumul <- matrix(NA, nrow = length(unique(newdata[,subject])), ncol = 1,
                   dimnames = list(unique(newdata[,subject]), "Y_cumul"))
  
  Y_cumul_row <- 1
  
  for (ind_subject in unique(newdata[,subject])){
    
    ###############################################################
    
    formula_terms <- paste("1 +", as.character(predRE$formul$fixed)[3])
    formula_terms <- strsplit(formula_terms, "+", fixed = TRUE)[[1]]
    
    eq <- c()
    
    for (i in 1:nrow(predRE$beta)){
      eq_part <- paste(predRE$beta[i,],"*", formula_terms[i])
      eq <- paste(eq, eq_part, "+")
    }
    
    
    eq <- substr(eq, 1, nchar(eq)-1)
    
    #############################################################
    
    function(year){
      
      X[, var_integrate] <- 
      
      function(year,beta,){
        
      }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    newdata_id <- newdata[newdata$id==num_id,]
    
    f_outcome <- function(t){
      predRE$beta[1] + predRE$beta[2]*t + predRE$beta[3]*newdata_id[,"sex"] + predRE$beta[4]*newdata_id[,"sex"]*t +
        predRE$b_i[rownames(predRE$b_i)==num_id,1] + predRE$b_i[rownames(predRE$b_i)==num_id,2]*t
    }
    
    Y_cumul[Y_cumul_row,] <- integrate(f_outcome, lower = tLM - tHW, upper = tLM)$value
    
    Y_cumul_row <- Y_cumul_row + 1
    
  }
  
  return(Y_cumul)
  
}

cumulY_newdata(predRE, newdata2, var_integrate = "year", 2, 4)

```

##### Niveau au dessus d'un seuil

```{r}

thresholdY_newdata <- function(){
  
}

```

### Landmark model à 4 ans

Etape 1 : calcul des random effect specifiques à chaque sujet

```{r}
data_training <- pbc2_landmark[,c("id", "year", "sex", "serBilir2")]
data_training$sex <- as.integer(data_training$sex) - 1

RE_training <- predRE_newdata(lmm_serBilir, data_training)
```

Etape 2 : calcul des resumés au temps landmark 4 ans

```{r}
data_training_LM <- data.frame()

# temps landmark 4

tLM <- 4

for (num_id in unique(data_training$id)){
  temp_id <- data_training[which(data_training$id==num_id),c("id","year","sex")]
  temp_id <- temp_id[which.min(temp_id$year),]
  temp_id$year <- tLM
  
  data_training_LM <- rbind(data_training_LM, temp_id)
}

# prediction au temps landmark
Y_training <- predY_newdata(RE_training, data_training_LM)

# pente au temps landmark
derivY_training <- derivY_newdata(RE_training, data_training_LM, derivForm)

# cumul des dernieres annees
cumulY_training <- cumulY_newdata(RE_training, data_training_LM, 2, 4)
```

Etape 3 : data survie avec les résumés

```{r}
data_training_surv <- data.frame()

for (num_id in unique(pbc2_landmark$id)){
  temp_id <- pbc2_landmark[which(pbc2_landmark$id==num_id),]
  temp_id <- temp_id[which.min(temp_id$year),]
  
  data_training_surv <- rbind(data_training_surv, temp_id)
}

# ajout des predictions
data_training_surv$year <- tLM
data_training_surv$serBilir2 <- Y_training[,1]
data_training_surv$serBilir <- exp(Y_training[,1])

# ajout des pentes
data_training_surv$serBilir2_slope <- derivY_training

# ajout des cumul
data_training_surv$serBilir2_cumul <- cumulY_training

# on exclut les patients ayant déjà eu l'evenement
data_training_surv <- data_training_surv[which(data_training_surv$years>data_training_surv$year),]

# kaplan meier
KM <- survfit(Surv(years, status2) ~ 1, data = data_training_surv)
plot(KM)
```

Etape 4 : cox model

Modele complet

```{r}
coxFit <- coxph(Surv(years, status2) ~ drug + age + sex + serBilir2 + serBilir2_slope +
                  drug*serBilir2 + age*serBilir2 + sex*serBilir2 +
                  drug*serBilir2_slope + age*serBilir2_slope + sex*serBilir2_slope +
                  serBilir2*serBilir2_slope, 
                data = data_training_surv)

summary(coxFit)
```

Modele restreint (pas à pas descendant)

```{r}
coxFit <- coxph(Surv(years, status2) ~ drug + age + serBilir2 + serBilir2_slope, 
                data = data_training_surv)

summary(coxFit)
```